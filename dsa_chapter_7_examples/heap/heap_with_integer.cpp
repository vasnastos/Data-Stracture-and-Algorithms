/* 
   ΣΩΡΟΙ####
     •Οι σωροί επιτρέπουν την οργάνωση των δεδομένων με τέτοιο τρόπο έτσι ώστε το μεγαλύτερο,μικρότερο στοιχείο να είναι συνεχώς
       προσπελάσιμο σε σταθερό χρόνο.
     •Πράξεις Σωρού::
        •Εύρεση του στοιχείου με τη μεγαλύτερη τιμή κλειδιού.
       • Διαγραφή του στοιχείου με τη μεγαλύτερη τιμή κλειδιού.
       • Εισαγωγή νέου κλειδιού στη δομή.
     •Στους Σωρούς ισχύει-->Κυριαρχία γονέα: το κλειδί σε κάθε κορυφή είναι μεγαλύτερο(MAXHEAP)/μικρότερο(MINHEAP) 
      ή ίσο από τα κλειδιά των παιδιών.
     •Ισχύουν οι παρακάτω ιδιότητες στον σωρό:
       •Στον πίνακα, τα κελιά γονείς βρίσκονται στις πρώτες ⌊n/2⌋ θέσεις ενώ τα φύλλα καταλαμβάνουν 
         τις υπόλοιπες θέσεις.
       • Στον πίνακα, τα παιδιά για κάθε κλειδί στις θέσεις i από 1 μέχρι και ⌊n/2⌋ 
         βρίσκονται στις θέσεις 2∗i και 2∗i+1.
       • Στον πίνακα, ο γονέας για κάθε κλειδί στις θέσεις i από 2 μέχρι και n βρίσκεται στη θέση ⌊i/2⌋.
    ΛΕΙΤΟΥΡΓΙΕΣ:
       push()-->Η εισαγωγή ενός στοιχείου γίνεται ως φύλλο στη πρώτη διαθέσιμη θέση από πάνω προς τα κάτω και από δεξιά προς τα
       αριστερά. Το στοιχείο αυτό συγκρίνεται με το γονέα του και αν είναι μεγαλύτερο αντιμετατίθεται με αυτόν. Η διαδικασία
       συνεχίζεται μέχρι είτε να βρεθεί το νέο στοιχείο στην κορυφή είτε να ισχύει η κυριαρχία γονέα.
       pop()-->Η εξαγωγή της μεγαλύτερης τιμής γίνεται ως εξής. Το στοιχείο που βρίσκεται στην κορυφή του σωρού αντιμετατίθεται με
       το τελευταίο στοιχείο του σωρού. Στη συνέχεια το στοιχείο που έχει βρεθεί στην κορυφή του σωρού κατεβαίνει προς τα κάτω
       αν έχει παιδί που είναι μεγαλύτερό του πραγματοποιώντας αντιμετάθεση με το μεγαλύτερο στοιχείο από τα παιδιά του. Η
       διαδικασία επαναλαμβάνεται για τη νέα θέση του στοιχείου που αρχικά είχε μεταφερθεί στη κορυφή και μέχρι να ισχύσει ότι
       είναι μεγαλύτερο και από τα δύο παιδιά του.
*/





#include <iostream>
class heap
{
    //MINHEAP(Σωρός ελαχίστων).
    const int static heap_limit=10000;
    int hs=0;
    int setsize=0;
    int heapb[heap_limit+1]{0};
    public:
     heap() {}
     heap(int size) {setsize=size;}
     ~heap() {}
     void clear()
     {
         for(int i=0;i<hs;i++)
         {
             heapb[i]=0;
         }
         hs=0;
     }
     bool empty() {return hs==0;}
     int top() {return heapb[1];}
     void push(int elem)
     {
         if(setsize!=0 && setsize==hs)
         {
             std::cerr<<"Full heap you can't add another element"<<std::endl;
             return;
         }
         hs++;
         heapb[hs]=elem;
         int pos=hs;
         while(pos!=1 && heapb[pos]>heapb[pos/2])
         {
            std::swap(heapb[pos],heapb[pos/2]);
            pos/=2;
         }
     }
     void heapify(int k)
     {
         int v=heapb[k];
         bool f=false;
         while(!f && 2*k<hs)
         {
             int j=2*k;
             if(j<hs)
             {
              if(heapb[j]<heapb[j+1])
              {
                  j++;
              }
              if(v>=heapb[j])
              {
                  f=true;
              }
              else
              {
                  heapb[k]=heapb[j];
                  k=j;
              }
             }
         heapb[k]=v;
         }
     }
     void pop()
     {
         std::swap(heapb[1],heapb[hs]);
         hs--;
         heapify(1);
     }
     void print()
     {
         std::cout<<"[";
         for(int i=1;i<=hs;i++)
         {
             if(i==hs)
             {
                std::cout<<heapb[i];
             }
             else
             {
                 std::cout<<heapb[i]<<",";
             }    
         }
         std::cout<<"]"<<std::endl;
     }
};

int main()
{
    std::cout<<"################## Max Heap Example ################"<<std::endl;
    heap h1;
    int a[10]={5,8,12,67,4,34,7,17,1,91};
    for(int i=0;i<sizeof(a)/sizeof(a[0]);i++)
    {
        h1.push(a[i]);
    }
    h1.heapify(1);
    std::cout<<"Top of heap:"<<h1.top()<<std::endl;
    h1.print();
    h1.pop();
    std::cout<<"Top after pop:"<<h1.top()<<std::endl;
    std::cout<<"Heap View:::"<<std::endl;
    h1.print();
}